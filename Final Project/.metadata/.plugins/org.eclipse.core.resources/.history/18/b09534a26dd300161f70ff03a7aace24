'''
Created on Nov 3, 2016

@author: branaugh
'''

import libtcodpy as libtcod
import textwrap
import time
import math
import shelve

#window size
screenWidth = 80
screenHeight = 43

#camera size
cameraWidth = 80
cameraHeight = 30

#dungeon size
dungeonWidth = 150
dungeonHeight = 150

#bottom panel size
barWidth = 20
panelHeight = 13
panelY = screenHeight - panelHeight

#message size
messageX = barWidth + 3
messageWidth = screenWidth - barWidth - 17
messageHeight = panelHeight - 6

inventoryWidth = 20
equipmentWidth = 20

healAmount = 20

#fog of war
fovAlg = 0
fovLightWalls = True
torchRadius = 10

#room parameters
roomMaxSize = 15
roomMinSize = 10
maxRooms = 20

limitFPS = 17

wall_tile = 256 
floor_tile = 257
player_tile = 258
orc_tile = 259
troll_tile = 260
scroll_tile = 261
healingpotion_tile = 262
sword_tile = 263
shield_tile = 264
stairsdown_tile = 265
dagger_tile = 266

dungeon1levelL1 = ['                                             XXXXXXXXXXXXXXXXXX   XXXXXXXX             XXXXXXXXXXX     ',
                   '                                             X----------------X   X------X             X---------X     ',
                   '                                             X----------------X   X------X             X---------X     ',
                   '                                             X----------------X   X------X             X---------X     ',
                   '                                             X----------------X   X------X             X---------X     ',
                   '                                             X----------------X   XXX--XXX             X---------X     ',
                   '                                             X----------------X     X--X               X---------X     ',
                   '                                             XXXXXXXXXXXXXXX--XXXXXXXX--XXXXXXXX       X---------X     ',  
                   '                                                          X--------------------X       X---------X     ',
                   '                                                          X--------------------X       XXXXX--XXXX     ',
                   '                                                          X--XXXXXXXXXXXXXXXX--X           X--X        ',
                   '                                                          X--X              X--X           X--X        ',
                   '                                                          X--X              X--X           X--X        ',
                   '                                                        XXX--XXX  XXXXXXXXXXX--X           X--X        ',
                   '                                                        X------X  X------------X           X--X        ',
                   '                                                        X------X  X------------X           X--X        ',
                   '                                                        X------X  X------------XXXXXXX     X--X        ',
                   '                                                        X------X  X------------------X     X--X        ',
                   '                                                        X------X  X------------------X  XXXX--XXXX     ',
                   '                                                        XXX--XXX  X------------XXXX--X  X--------X     ',
                   '                                                          X--X    X------------X  X--XXXX--------X     ',
                   '                                                          X--X    XXXXXXXXXXXXXX  X--------------X     ',
                   '                                                          X--X                    X--------------X     ',
                   '                                                        XXX--XXXXX                XXXXXXXX--XXXXXX     ',
                   '                                                        X--------X                       X--X          ',
                   '                                                        X--------X                  XXXXXX--XXXXXXXXXXX',
                   '                                                        X--------X                  X-----------------X',
                   '                                                        X--------XXXXXXXXXXXXX      X-----------------X',
                   '                                                        X--------------------X      X-----------------X',
                   '                                                        X--------------------X      X-----------------X',
                   '                                                        XXXXXXXXXXXXXXXXXXX--X      X-----------------X',      
                   '                                                                          X--X      X-----------------X',
                   '                                                                          X--X      X-----------------X',
                   '                                                                    XXXXXXX--X      X-----------------X',
                   '                        XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  X--------X      X-----------------X',
                   '                        X----------------------------------------X  X--------X      XXXXXXXXXXXXXXXXXXX',
                   '                        X----------------------------------------X  X--XXXXXXX                         ',
                   '                        X--XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX------X  X--X                               ',
                   '                        X--X                              X------X  X--X                               ',
                   '                        X--X            XXXXXXXXXXXXXX    X------XXXX--X XXXXXXXXX  XXXXXXXXX          ',
                   '             XXXXXXXXXXXX--XXXXXXXXXXXX X------------X    X------------X X-------X  X-------X          ',
                   '             XX---------X--X----------X X------------X    X------------X X-------X  X-------X          ',
                   '             XX---------X--X----------X X------------X    X------XXXX--X X-------X  X-------X          ',
                   '             XX-----------------------X X------------X    XXXXXXXXXXX--X X-------X  X-------X          ',
                   '             XX-----------------------X X------------X              X--X X-------X  X-------X          ',
                   '             XXXXXXXXXXXX--XXXXXXXXXXXX XXXXXXXXXXX--X   XXXXXXXX   X--X XXXX--XXXXXXXX--XXXX          ',
                   '                        X--X                      X--X   X------X   X--X    X--X      X--X             ',
                   '                        X--X   XXXXXXXX           X--X   X------X   X--XXXXXX--XXXXXXXX--XXXXXXXXX     ',
                   '                        X--X   X------XXXXXXXX    X--X   X------X   X----------------------------X     ',
                   '                       XX--XX  X-------------X    X--X   X------X   X----------------------------X     ',
                   '             XXXXXXXXXXX----X  X-------------X    X--X   XXXX--XX   XXXXXXXXXXXXXXXXXXXXXXXXXXX--X     ',
                   '             X--------------X  X------XXXXX--X    X--X      X--X                              X--X     ',
                   '             X--------------X  XXX--XXX   X--X    X--X      X--X  XXXXXXXXXXXXXXXXX  XXXXXXXXXX--X     ',
                   '             X--XXXXXXXX----X    X--X     X--XXXXXX--XXXXXXXX--X  X---------------X  X-----------X     ',
                   '             X--X      X----X    X--X     X--------------------X  X---------------X  X-----------X     ',
                   '             X--X      X----X    X--X     X--------------------X  X------XXXX--X--XXXX-----------X     ',
                   '             X--XXXX   X----X    X--X     X--XXXXXXXXXXXXXXXX--X  X------X  X--X-----------------X     ',
                   '             X-----X   XX--XX  XXX--XXXX  X--X              X--X  XXX--XXX  X--X-----------------X     ',
                   '             X-----X    X--X   X-------X XX--XXXX           X--X    X--X    X--XXXXXXX-----------X     ',
                   '             X-----X    X--X   X-------X X------X      XXXXXX--X    X--X    X--X     X-----------X     ',
                   '             X-----X    X--XXXXX-------X X------X      X-------XXXXXX--X  XXX--XXX   X-----------X     ',
                   '             X-----X    X--------------X X------X      X---------------X  X------X   X-----------X     ',
                   '             X-----X    X--------------X X------X      X---------------X  X------X   XXXXXXXXXXXXX     ',
                   '             X-----X    XXXXXXXX-------X XXXXXXXX      X--------XXXXXXXX  X------X                     ',
                   '             XXXXXXX           X-------X               X--------X         XXXXXXXX                     ',
                   '                               XXXXXXXXX               XXXXXXXXXX                                      ']

                   

class Tile:
    def __init__(self, blocked, block_sight = None):
        self.blocked = blocked
        self.explored = False
        if block_sight is None: block_sight = blocked
        self.block_sight = block_sight
    
class Rect:
    def __init__(self,x,y,w,h):
        self.x1 = x
        self.y1 = y
        self.x2 = x + w
        self.y2 = y + h
    
    def center(self):
        center_x = (self.x1 + self.x2) / 2
        center_y = (self.y1 + self.y2) / 2
        return (center_x, center_y)
    
    def intersect(self,other):
        return(self.x1 <= other.x2 and self.x2 >= other.x1 and self.y1 <= other.y2 and self.y2 >= other.y1)
        
class Object:
    def __init__(self,x,y,char,name,color,timerStart,speed,moveSpeed,attacking=False,blocks=False,fighter=None, ai=None, item=None, equipment=None,description="None yet!"):
        self.x = x
        self.y = y
        self.char = char
        self.name = name
        self.color = color
        self.timerStart = timerStart
        self.speed = speed
        self.moveSpeed = moveSpeed
        self.wait = 0
        self.attacking = attacking
        self.blocks = blocks
        self.fighter = fighter
        self.description = description
        if self.fighter:
            self.fighter.owner = self
            
        self.ai = ai
        if self.ai:
            self.ai.owner = self
            
        self.item = item
        if self.item:
            self.item.owner = self
            
        self.equipment = equipment
        if self.equipment:
            self.equipment.owner = self
            self.item = Item()
            self.item.owner = self
        
    def move(self, dx, dy):
        if not is_blocked(Tile(self.x+dx,self.y+dy)):
            self.x = self.x + dx
            self.y = self.y + dy
            self.wait = self.moveSpeed
            
    def move_towards(self,targetX,targetY):
        dx = targetX - self.x
        dy = targetY - self.y
        distance = math.sqrt(dx**2 + dy**2)
        dx = int(round(dx/distance))
        dy = int(round(dy/distance))
        self.move(dx,dy)
        
    def pathing(self,target):
        fov = libtcod.map_new(dungeonWidth,dungeonHeight)
        for height in range(dungeonHeight):
            for width in range(dungeonWidth):
                libtcod.map_set_properties(fov,width,height,not dungeon[width][height].block_sight,not dungeon[width][height].blocked)
                
        for object in objects:
            if object.blocks and object != self and object != target:
                libtcod.map_set_properties(fov,object.x,object.y,True,False)
                
        path = libtcod.path_new_using_map(fov, 1.41)
        libtcod.path_compute(path,self.x,self.y,target.x,target.y)
        
        if not libtcod.path_is_empty(path) and libtcod.path_size(path) < 25:
            x, y = libtcod.path_walk(path, True)
            if x or y:
                self.x = x
                self.y = y
                self.wait = self.moveSpeed

        else:
            self.move_towards(target.x,target.y)
        
        libtcod.path_delete(path)
        
    def distance_to(self,other):
        dx = other.x - self.x
        dy = other.y - self.y
        return math.sqrt(dx ** 2 + dy ** 2)
    
    def send_to_back(self):
        global objects
        objects.remove(self)
        objects.insert(0,self)
           
    def draw(self):
        if libtcod.map_is_in_fov(fovMap,self.x,self.y):
            (x, y) = to_camera_coordinates(self.x, self.y)
            if x is not None:
                libtcod.console_set_default_foreground(con,self.color)
                libtcod.console_put_char(con,x,y,self.char,libtcod.BKGND_NONE)
        
    def clear(self):
        (x, y) = to_camera_coordinates(self.x, self.y)
        if x is not None:
            libtcod.console_put_char(con,x,y,' ',libtcod.BKGND_NONE)
    
class Fighter:
    def __init__(self,hp,defense,power,mana = 0,experienceWorth = 0,death_function=None):
        self.base_max_hp = hp
        self.hp = hp
        self.base_defense = defense
        self.base_power = power
        self.base_max_mana = mana
        self.mana = mana
        self.experienceWorth = experienceWorth
        self.death_function = death_function
     
    @property   
    def power(self):
        global equipped_list
        bonus = sum(equipment.equipment.power_bonus for equipment in equipped_list)
        return self.base_power + bonus
    
    @property   
    def defense(self):
        global equipped_list
        bonus = sum(equipment.equipment.defense_bonus for equipment in equipped_list)
        return self.base_defense + bonus
    
    @property   
    def max_hp(self):
        global equipped_list
        bonus = sum(equipment.equipment.max_hp_bonus for equipment in equipped_list)
        return self.base_max_hp + bonus
    
    @property   
    def max_mana(self):
        global equipped_list
        bonus = sum(equipment.equipment.max_mana_bonus for equipment in equipped_list)
        return self.base_max_mana + bonus
    
    def attack(self,target):
        damage = self.power-target.fighter.defense
        
        if damage > 0:
            message(self.owner.name.capitalize() + ' attacks ' + target.name + ' for ' + str(damage) + ' damage.', libtcod.green)
            target.fighter.take_damage(damage)
        else:
            message(self.owner.name.capitalize() + ' attacks ' + target.name + ', but it has no effect!', libtcod.orange)
        
    def take_damage(self,damage):
        if damage > 0:
            self.hp = self.hp - damage
            if self.hp <= 0:
                function = self.death_function
                if function is not None:
                    function(self.owner)
                    
    def heal(self,amount):
        self.hp = self.hp + amount
        if self.hp > self.max_hp:
            self.hp = self.max_hp
        
class BasicMonster:
    def take_turn(self):
        global player
        timer = int(time.time())
        monster = self.owner
        if libtcod.map_is_in_fov(fovMap,monster.x,monster.y):
            if monster.distance_to(player) >= 2:
                monster.pathing(player)
            elif player.fighter.hp > 0:
                if monster.attacking == False:
                    monster.timerStart = timer
                    monster.fighter.attack(player)                
                    monster.attacking = True
                else:
                    if timer == monster.timerStart + monster.speed:
                        monster.timerStart = timer
                        monster.fighter.attack(player)                    
            else:
                if monster.attacking == True:
                    monster.attacking = False
                    
class Item:
    def __init__(self,use_function=None):
        self.use_function = use_function
        
    def pick_up(self):
        if len(inventory) >= 40:
            message('Your inventory is too full to pick up that ' + self.owner.name + '.', libtcod.orange)
        else:
            inventory.append(self.owner)
            objects.remove(self.owner)
            message('You picked up a ' + self.owner.name + '.', libtcod.green)
            
            equipment = self.owner.equipment
            if equipment and get_equipped_in_slot(equipment.slot) is None:
                equipment.equip()   
            
    def use(self):
        if self.use_function is None:
            message('The ' + self.owner.name + 'cannot be used.', libtcod.orange)     
        else:
            if self.use_function() != 'cancelled':
                inventory.remove(self.owner)    
                
    def drop(self): 
        global player
        objects.append(self.owner)
        inventory.remove(self.owner)  
        self.owner.x = player.x
        self.owner.y = player.y+1
        message("You dropped the " + self.owner.name + ".", libtcod.orange)

class Equipment:
    def __init__ (self,slot,power_bonus=0,defense_bonus=0,max_hp_bonus=0,max_mana_bonus=0,ranged=False):
        self.power_bonus=power_bonus
        self.defense_bonus=defense_bonus
        self.max_hp_bonus = max_hp_bonus
        self.max_mana_bonus = max_mana_bonus
        self.ranged = ranged
        
        self.slot = slot
        self.is_equipped = False
            
    def equip(self):
        global equipped_list
        oldEquipment = get_equipped_in_slot(self.slot)
        if oldEquipment is not None:
            oldEquipment.dequip()
        self.is_equipped = True
        equipped_list.append(self.owner)
        if self.owner in inventory:
            inventory.remove(self.owner)
        message('Equipped ' + self.owner.name + ' on ' + self.slot + '.',libtcod.green)
        
    def dequip(self):
        global equipped_list
        if self.is_equipped == True:
            self.is_equipped = False
            equipped_list.remove(self.owner)
            inventory.append(self.owner)
            message('Dequipped ' + self.owner.name + ' from ' + self.slot + '.', libtcod.green)

class Spell:
    def __init__ (self, name, icon, type, range, manaRequired, damage = 0,learned = False, description = "None yet."):
        self.name = name
        self.icon = icon
        self.type = type
        self.range = range
        self.manaRequired = manaRequired
        self.damage = damage
        self.learned = learned
        self.description = description
    
    def cast(self):
        global player
        message("Casting a spell...please select a target.",libtcod.orange)
        if self.manaRequired <= player.fighter.mana:
            if self.type == 'single-target':
                target = target_monster()
                if target is not None:
                    if (target.x <= self.range + player.x) and (target.y <= self.range + player.y):
                        message(player.name.capitalize() + ' casts ' + self.name + ' at ' + target.name + ' for ' + str(self.damage) + ' damage.', libtcod.green)
                        target.fighter.take_damage(self.damage)
                        player.fighter.mana = player.fighter.mana - self.manaRequired
                    else:
                        message("You are too far away from that target.", libtcod.orange)
                else:
                    message("No target selected, please try again.", libtcod.orange)
        else:
            message("Not enough mana!", libtcod.orange)
                    
def load_customfont():
    a = 256
    for y in range(5,6):
        libtcod.console_map_ascii_codes_to_font(a,32,0,y)
        a = a + 32
        
def get_equipped_in_slot(slot):
    for obj in equipped_list:
        if obj.equipment.slot == slot: 
            return obj.equipment
    return None
        
def is_blocked(x,y):  
    if Tile(dungeon[x][y]).blocked:
        return True
    for object in objects:
        if object.blocks and object.x == x and object.y == y:
            return True
    return False   
        
def createRoom(room):
    global dungeon
    for x in range(room.x1 + 1, room.x2):
        for y in range(room.y1 + 1, room.y2):
            dungeon[x][y].blocked = False
            dungeon[x][y].block_sight = False
        
def createHorizontalTunnel(x1,x2,y):
    global dungeon
    for x in range(min(x1,x2), max(x1,x2) + 1):
        dungeon[x][y].blocked = False
        dungeon[x][y].block_sight = False
        dungeon[x+1][y+1].blocked = False
        dungeon[x+1][y+1].block_sight = False
        
def createVerticalTunnel(y1,y2,x):
    global dungeon
    for y in range(min(y1,y2), max(y1,y2) + 1):
        dungeon[x][y].blocked = False
        dungeon[x][y].block_sight = False
        dungeon[x+1][y+1].blocked = False
        dungeon[x+1][y+1].block_sight = False
        
def makeRandomMap():
    global dungeon, objects, player, stairs
    
    objects = [player]
    dungeon = [[Tile(True) for y in range (dungeonHeight)] for x in range(dungeonWidth)]
    
    #dungeon generation algorithm
    rooms = []
    num_rooms = 0
    
    for r in range(maxRooms):
        w = libtcod.random_get_int(0,roomMinSize,roomMaxSize)
        h = libtcod.random_get_int(0,roomMinSize,roomMaxSize)
        x = libtcod.random_get_int(0,0,dungeonWidth-w-1)
        y = libtcod.random_get_int(0,0,dungeonHeight-h-1)
        
        new_room = Rect(x,y,w,h)
        
        failed = False
        for other_room in rooms:
            if new_room.intersect(other_room):
                failed = True
                break
        if not failed:
            createRoom(new_room)
            (new_x,new_y) = new_room.center()
            
            if num_rooms == 0:
                player.x = new_x
                player.y = new_y
            else:
                (prev_x,prev_y) = rooms[num_rooms-1].center()
                if libtcod.random_get_int(0,0,1)==1:
                    createHorizontalTunnel(prev_x,new_x,prev_y)
                    createVerticalTunnel(prev_y,new_y,new_x)
                else:
                    createVerticalTunnel(prev_y,new_y,prev_x)
                    createHorizontalTunnel(prev_x,new_x,new_y)
            place_objects(new_room)
            rooms.append(new_room)
            num_rooms = num_rooms + 1
    stairs = Object(new_x,new_y, stairsdown_tile,'stairs',libtcod.white,0,0,0)
    objects.append(stairs)
    stairs.send_to_back()
    
def makeMap(map):
    global dungeon,objects,player,stairs
    
    objects = [player]
    dungeon = map
    for x in range(len(dungeon)):
        for y in range(len(dungeon[0])):
            if dungeon[x][y] == 'X':
                print x,y
                Tile(dungeon[x][y]).blocked == True
                Tile(dungeon[x][y]).block_sight == True

def random_choice_index(chances):
    dice = libtcod.random_get_int(0,1,sum(chances))
    total = 0
    choice = 0
    
    for w in chances:
        total = total + w
        if dice <= total:
            return choice
        choice = choice + 1
        
def random_choice(chances_dict):
    chances = chances_dict.values()
    strings = chances_dict.keys()
    return strings[random_choice_index(chances)]

def from_dungeon_level(table):
    for (value, level) in reversed(table):
        if dungeonLevel >= level:
            return value
    return 0
 
def place_objects(room):
    maxMonsters = from_dungeon_level([[2,1],[3,4],[5,6]])
    monsterChances = {}
    monsterChances['orc'] = 80
    monsterChances['troll'] = from_dungeon_level([[15,2],[30,4],[60,6]])
    
    maxItems = from_dungeon_level([[1,1],[2,4]])
    itemChances = {}
    itemChances['heal'] = 35
    itemChances['sword'] = 50
    itemChances['bow'] = from_dungeon_level([[25,4]])
    
    numMonsters = libtcod.random_get_int(0,0,maxMonsters)
    
    for i in range(numMonsters):
        x = libtcod.random_get_int(0,room.x1+1,room.x2-1)
        y = libtcod.random_get_int(0,room.y1+1,room.y2-1)
        
        if not is_blocked(x,y):
            choice = random_choice(monsterChances)
            if choice == 'orc':
                fighter_component = Fighter(hp=20,defense=0,power=4,experienceWorth=40,death_function=monster_death)
                ai_component = BasicMonster()
                monster = Object(x, y, orc_tile,'orc', libtcod.white, 0, 3, 5, False, blocks=True, fighter = fighter_component, ai = ai_component)
            elif choice == 'troll':
                fighter_component = Fighter(hp=30,defense=2,power=8,experienceWorth=80,death_function=monster_death)
                ai_component = BasicMonster()
                monster = Object(x, y, troll_tile,'troll', libtcod.white, 0, 5, 5, False, blocks=True, fighter = fighter_component, ai = ai_component)
            objects.append(monster)
            
    numItems = libtcod.random_get_int(0,0,maxItems)
    for i in range(numItems):
        x = libtcod.random_get_int(0,room.x1+1,room.x2-1)
        y = libtcod.random_get_int(0,room.y1+1,room.y2-1)
        if not is_blocked(x,y):
            choice = random_choice(itemChances)
            if choice == 'heal':
                item_component = Item(use_function = cast_heal)
                item = Object(x,y,healingpotion_tile,'potion', libtcod.white, 0, 0, 0, item=item_component,description="A healing potion. Heals 20 hit points.")
            if choice == 'sword':   
                equipment_component = Equipment(slot='weapon', power_bonus=2)
                item = Object(x,y,sword_tile,'sword', libtcod.white, 0, 0, 0, equipment=equipment_component,description="A basic sword. Increases power by 2.")
            if choice == 'bow':
                equipment_component = Equipment(slot='weapon', power_bonus = 3, ranged=True)
                item = Object(x,y,shield_tile,'bow', libtcod.white, 0, 0, 0, equipment=equipment_component,description="A basic, ranged bow. Increases power by 3.")
            objects.append(item)
            item.send_to_back()
    
def render_bar(x,y,totalWidth,name,value,maximum,barColor,backColor):
    barWidth = int(float(value)/maximum*totalWidth)
    
    libtcod.console_set_default_background(panel,backColor)
    libtcod.console_rect(panel,x,y,totalWidth,1,False,libtcod.BKGND_SCREEN)
    
    libtcod.console_set_default_background(panel,barColor)
    if barWidth > 0:
        libtcod.console_rect(panel,x,y,barWidth,1,False,libtcod.BKGND_SCREEN)
        
    libtcod.console_set_default_foreground(panel, libtcod.white)
    libtcod.console_print_ex(panel,x+totalWidth/2,y, libtcod.BKGND_NONE, libtcod.CENTER,name + ': ' + str(value) + '/' + str(maximum))
  
def get_names_under_mouse():
    global mouse, camera_x, camera_y
    (x,y) = (mouse.cx,mouse.cy)
    (x, y) = (camera_x + x, camera_y + y)
    
    names = [object.name for object in objects if object.x == x and object.y == y and libtcod.map_is_in_fov(fovMap,object.x,object.y)]
    names = ' , '.join(names)
    return names.capitalize() 

def move_camera(target_x, target_y):
    global camera_x, camera_y, fovRecompute
 
    x = target_x - cameraWidth / 2  
    y = target_y - cameraHeight / 2
 
    if x < 0: 
        x = 0
    if y < 0: 
        y = 0
    if x > len(dungeon) - cameraWidth - 1: 
        x = len(dungeon) - cameraWidth - 1
    if y > len(dungeon[0]) - cameraHeight - 1: 
        y = len(dungeon[0]) - cameraHeight - 1
 
    if x != camera_x or y != camera_y: 
        fovRecompute = True
    (camera_x, camera_y) = (x, y)
 
def to_camera_coordinates(x, y):
    global camera_x,camera_y
    (x, y) = (x - camera_x, y - camera_y)
    if (x < 0 or y < 0 or x >= cameraWidth or y >= cameraHeight):
        return (None, None)
    return (x, y)
 
def renderAll():
    global dungeon
    global fovRecompute, fovMap
    global prevTime
    global camera_x,camera_y
    global playerExperiencePoints, experienceMax
    global hotbarAbilities
    
    move_camera(player.x, player.y)
    
    if fovRecompute:
        fovRecompute = False
        libtcod.map_compute_fov(fovMap, player.x, player.y, torchRadius, fovLightWalls, fovAlg)
        libtcod.console_clear(con)
    
    for y in range(cameraHeight):
        for x in range(cameraWidth):
            (map_x, map_y) = (camera_x + x, camera_y + y)
            visible = libtcod.map_is_in_fov(fovMap, map_x, map_y)          
            
            if not visible:
                #print 'here1'
                if Tile(dungeon[map_x][map_y]).explored:
                    if dungeon[map_x][map_y] == 'X':
                        libtcod.console_set_char_background(con,x,y,libtcod.dark_gray, libtcod.BKGND_SET) 
                    elif dungeon[map_x][map_y] == '-':
                        libtcod.console_set_char_background(con,x,y,libtcod.gray, libtcod.BKGND_SET)
            else:
                #print 'here2'
                if dungeon[map_x][map_y] == 'X':
                    libtcod.console_put_char_ex(con,x,y,wall_tile,libtcod.grey,libtcod.black)
                elif dungeon[map_x][map_y] == '-':
                    libtcod.console_put_char_ex(con,x,y,floor_tile,libtcod.grey,libtcod.black)
                Tile(dungeon[map_x][map_y]).explored = True
     
    for object in objects:
        object.draw()
        
    libtcod.console_blit(con,0,0,screenWidth,screenHeight,0,0,0)
    
    libtcod.console_set_default_background(panel,libtcod.black)
    libtcod.console_clear(panel)
    
    #message menu
    libtcod.console_set_default_background(panel,libtcod.dark_gray)
    libtcod.console_rect(panel,(messageX-1),5,(screenWidth/2+5),7,False,libtcod.BKGND_SCREEN)
    libtcod.console_blit(panel,0,0,screenWidth,panelHeight,0,0,panelY)
    
    #ability menu
    libtcod.console_set_default_background(panel,libtcod.dark_gray)
    libtcod.console_rect(panel,(messageX+3),0,(screenWidth/2-3),4,False,libtcod.BKGND_SCREEN)
    libtcod.console_set_default_background(panel,libtcod.darkest_gray)
    libtcod.console_rect(panel,27,1,3,2,False,libtcod.BKGND_SCREEN)
    libtcod.console_rect(panel,31,1,3,2,False,libtcod.BKGND_SCREEN)
    libtcod.console_rect(panel,35,1,3,2,False,libtcod.BKGND_SCREEN)
    libtcod.console_rect(panel,39,1,3,2,False,libtcod.BKGND_SCREEN)
    libtcod.console_rect(panel,43,1,3,2,False,libtcod.BKGND_SCREEN)
    libtcod.console_rect(panel,47,1,3,2,False,libtcod.BKGND_SCREEN)
    libtcod.console_rect(panel,51,1,3,2,False,libtcod.BKGND_SCREEN)
    libtcod.console_rect(panel,55,1,3,2,False,libtcod.BKGND_SCREEN)
    libtcod.console_rect(panel,59,1,3,2,False,libtcod.BKGND_SCREEN)
    
    x = 28
    y = 1
    for ability in hotbarAbilities:
        image = ability.icon
        libtcod.console_put_char(panel,x,y,image,libtcod.BKGND_SCREEN)
        x = x + 4

    libtcod.console_blit(panel,0,0,screenWidth,panelHeight,0,0,panelY)
    
    #inventory button
    libtcod.console_set_default_background(panel,libtcod.dark_gray)
    libtcod.console_rect(panel,(screenWidth-12),5,(screenWidth/2-37),2,False,libtcod.BKGND_SCREEN)
    libtcod.console_blit(panel,0,0,screenWidth,panelHeight,0,0,panelY)
    
    #equipment button
    libtcod.console_set_default_background(panel,libtcod.dark_gray)
    libtcod.console_rect(panel,(screenWidth-8),5,(screenWidth/2-37),2,False,libtcod.BKGND_SCREEN)
    libtcod.console_blit(panel,0,0,screenWidth,panelHeight,0,0,panelY)
    
    #abilities button
    libtcod.console_set_default_background(panel,libtcod.dark_gray)
    libtcod.console_rect(panel,(screenWidth-4),5,(screenWidth/2-37),2,False,libtcod.BKGND_SCREEN)
    libtcod.console_blit(panel,0,0,screenWidth,panelHeight,0,0,panelY)

    y = 5
    for (line,color) in allMessages:
        libtcod.console_set_default_foreground(panel,color)
        libtcod.console_print_ex(panel, messageX, y, libtcod.BKGND_NONE, libtcod.LEFT, line)
        y = y + 1
    
    #status bars
    render_bar(1,3,barWidth,'HP',player.fighter.hp,player.fighter.max_hp,libtcod.light_red,libtcod.darker_red)
    render_bar(1,7,barWidth,'Mana',player.fighter.mana,player.fighter.max_mana,libtcod.light_blue,libtcod.darker_blue)
    render_bar(1,9,barWidth,'Exp',playerExperiencePoints,experienceMax,libtcod.light_green,libtcod.darker_green)
    
    currentTime = abs(int(prevTime+1-time.time()))
    if currentTime > 1:
        currentTime = 1 
    render_bar(1,5,barWidth,'Stamina',currentTime,1, libtcod.light_fuchsia, libtcod.darker_fuchsia)
    
    libtcod.console_print_ex(panel,screenWidth-12,10,libtcod.BKGND_NONE,libtcod.LEFT,'Floor: B' + str(dungeonLevel))

    libtcod.console_set_default_foreground(panel,libtcod.light_gray)
    libtcod.console_print_ex(panel,1,11,libtcod.BKGND_NONE, libtcod.LEFT,get_names_under_mouse())

    libtcod.console_blit(panel,0,0,screenWidth,panelHeight,0,0,panelY)
   
def message(newMessage, color = libtcod.white):
    global allMessages
    newMessageLines = textwrap.wrap(newMessage, messageWidth)  
    
    for line in newMessageLines:
        if len(allMessages) == messageHeight:
            del allMessages[0]
        allMessages.append((line,color))
     
     
def player_select_or_attack(mousex,mousey,lastTime):
    global mouse
    global cantAttack
    global hotbarAbilities
    global allAbilities
    timer = int(time.time())
    
    x = mousex
    y = mousey
    
    #spell buttons
    if (x >= 27 and x <= 29) and (y >= 31 and y <= 33):
        if len(hotbarAbilities) <= 0:
            message("No spell loaded.", libtcod.orange)
        else:
            hotbarAbilities[0].cast()
        return
            
    elif (x >= 31 and x <= 33) and (y >= 31 and y <= 33):
        if len(hotbarAbilities) <= 1:
            message("No spell loaded.", libtcod.orange)
        else:
            hotbarAbilities[1].cast()
        return
        
    elif (x >= 35 and x <= 37) and (y >= 31 and y <= 33):
        if len(hotbarAbilities) <= 2:
            message("No spell loaded.", libtcod.orange)
        else:
            hotbarAbilities[2].cast()
        return 
                   
    elif (x >= 39 and x <= 41) and (y >= 31 and y <= 33):
        if len(hotbarAbilities) <= 3:
            message("No spell loaded.", libtcod.orange)
        else:
            hotbarAbilities[3].cast()
        return
                    
    elif (x >= 43 and x <= 45) and (y >= 31 and y <= 33):
        if len(hotbarAbilities) <= 4:
            message("No spell loaded.", libtcod.orange)
        else:
            hotbarAbilities[4].cast()
        return
                    
    elif (x >= 47 and x <= 49) and (y >= 31 and y <= 33):
        if len(hotbarAbilities) <= 5:
            message("No spell loaded.", libtcod.orange)
        else:
            hotbarAbilities[5].cast()
        return
                    
    elif (x >= 51 and x <= 53) and (y >= 31 and y <= 33):
        if len(hotbarAbilities) <= 6:
            message("No spell loaded.", libtcod.orange)
        else:
            hotbarAbilities[6].cast()
        return
                    
    elif (x >= 55 and x <= 57) and (y >= 31 and y <= 33):
        if len(hotbarAbilities) <= 7:
            message("No spell loaded.", libtcod.orange)
        else:
            hotbarAbilities[7].cast() 
        return
                   
    elif (x >= 59 and x <= 61) and (y >= 31 and y <= 33):
        if len(hotbarAbilities) <= 8:
            message("No spell loaded.", libtcod.orange)
        else:
            hotbarAbilities[8].cast()
        return
                
    #inventory menu
    elif (x >= 68 and x <= 70) and (y >= 34 and y <= 36):
        chosenItem = inventory_menu('Left click to use, right click to drop permanently, or enter to cancel.\n')
        if drop == False:
            if chosenItem is not None:
                if chosenItem.equipment:
                    chosenItem.equipment.equip()
                else:
                    chosenItem.item.use()
        else:
            if chosenItem is not None:
                chosenItem.drop()
        return
    
    #equipment menu
    elif (x >= 72 and x <= 74) and (y >= 34 and y <= 36):
        chosenItem = equipment_menu('Click the item you would like to dequip, or press enter to cancel.\n')
        if chosenItem is not None:
            chosenItem.equipment.dequip()
        return
    
    #abilities menu
    elif (x >= 76 and x <= 78) and (y >= 34 and y <= 36):
        chosenAbility = abilities_menu('Select an ability to add it to your hotbar, or press enter to cancel.\n')
        if chosenAbility is not None:
            if chosenAbility not in hotbarAbilities and chosenAbility.learned == True:
                hotbarAbilities.append(chosenAbility)
                message(chosenAbility.name.capitalize() + " added to hotbar.", libtcod.green)
            elif chosenAbility not in hotbarAbilities and chosenAbility.learned == False:
                if playerSkillPoints > 0:
                    message("You have not yet learned that ability. However, you have enough skill points to learn it. Right click the spell to learn it.", libtcod.orange)
                else:
                    message("You have not yet learned that ability!", libtcod.orange)
            elif chosenAbility in hotbarAbilities:
                hotbarAbilities.remove(chosenAbility)
                message(chosenAbility.name.capitalize() + " removed from hotbar.")
            return
            
    
    (x, y) = (camera_x + x, camera_y + y)
    
    target = None
    for object in objects:
        if object.x == x and object.y == y:
            if object.fighter is not None:
                target = object
                break
        
    if target is not None:
        if get_equipped_in_slot('weapon') != None:
            if get_equipped_in_slot('weapon').ranged == False:
                if (target.x == player.x+1 and target.y == player.y) or (target.x == player.x-1 and target.y == player.y) or (target.x == player.x and target.y == player.y+1) or (target.x == player.x and target.y == player.y-1) or (target.x == player.x+1 and target.y == player.y+1) or (target.x == player.x-1 and target.y == player.y+1) or (target.x == player.x+1 and target.y == player.y-1) or (target.x == player.x-1 and target.y == player.y-1):
                    if (timer >= lastTime+1):
                        cantAttack = False
                        player.fighter.attack(target)
                    else:
                        message("You can't attack yet!", libtcod.orange)
                else:
                    message("You are not close enough to attack that monster!", libtcod.orange)
            else:
                if libtcod.map_is_in_fov(fovMap, target.x, target.y):
                    if (timer >= lastTime+1):
                        cantAttack = False
                        player.fighter.attack(target)
                    else:
                        message("You can't attack yet!", libtcod.orange)
        else:
            if libtcod.map_is_in_fov(fovMap, target.x, target.y):
                if (timer >= lastTime+1):
                    cantAttack = False
                    player.fighter.attack(target)
                else:
                    message("You can't attack yet!", libtcod.orange)

def mainMenuGraphic(header,options,width):
    if len(options) > 26: 
        raise ValueError('Cannot have a menu with more than 26 options.')
 
    #calculate total height for the header (after auto-wrap) and one line per option
    header_height = libtcod.console_get_height_rect(con, 0, 0, width, screenHeight, header)
    if header == '':
        header_height = 0
    height = len(options) + header_height
 
    #create an off-screen console that represents the menu's window
    window = libtcod.console_new(width, height)
 
    #print the header, with auto-wrap
    libtcod.console_set_default_foreground(window, libtcod.white)
    libtcod.console_print_rect_ex(window, 0, 0, width, height, libtcod.BKGND_NONE, libtcod.LEFT, header)
 
    #print all the options
    y = header_height
    letter_index = ord('a')
    for option_text in options:
        text = '(' + chr(letter_index) + ') ' + option_text
        libtcod.console_print_ex(window, 0, y, libtcod.BKGND_NONE, libtcod.LEFT, text)
        y += 1
        letter_index += 1
 
    x = screenWidth/2 - width/2
    y = screenHeight/2 - height/2
    libtcod.console_blit(window, 0, 0, width, height, 0, x, y, 1.0, 1.0)
 
    libtcod.console_flush()
    key = libtcod.console_wait_for_keypress(True)
 
    index = key.c - ord('a')
    if index >= 0 and index < len(options): 
        return index
    return None

def levelUpMenu(header,options,width):
    if len(options) > 26: 
        raise ValueError('Cannot have a menu with more than 26 options.')
 
    #calculate total height for the header (after auto-wrap) and one line per option
    header_height = libtcod.console_get_height_rect(con, 0, 0, width, screenHeight, header)
    if header == '':
        header_height = 0
    height = len(options) + header_height
 
    #create an off-screen console that represents the menu's window
    window = libtcod.console_new(width, height)
 
    #print the header, with auto-wrap
    libtcod.console_set_default_foreground(window, libtcod.white)
    libtcod.console_print_rect_ex(window, 0, 0, width, height, libtcod.BKGND_NONE, libtcod.LEFT, header)
 
    #print all the options
    y = header_height
    letter_index = ord('a')
    for option_text in options:
        text = '(' + chr(letter_index) + ') ' + option_text
        libtcod.console_print_ex(window, 0, y, libtcod.BKGND_NONE, libtcod.LEFT, text)
        y += 1
        letter_index += 1
 
    x = screenWidth/2 - width/2
    y = screenHeight/2 - height/2
    libtcod.console_blit(window, 0, 0, width, height, 0, x, y, 1.0, 1.0)
 
    libtcod.console_flush()
    key = libtcod.console_wait_for_keypress(True)
 
    index = key.c - ord('a')
    if index >= 0 and index < len(options): 
        return index
    return None
        
def inventory_menu(header):
    options = [item for item in inventory]
    global key,mouse
    global drop 
    drop = False
    
    if len(options) > 40: raise ValueError('Cannot have a menu with more than 40 options.')
    
    headerHeight = libtcod.console_get_height_rect(con,0,0,inventoryWidth,screenHeight,header)
    if header == '':
        headerHeight = 0
    height = 20 + headerHeight
    
    window = libtcod.console_new(inventoryWidth,height)
    libtcod.console_set_default_background(window,libtcod.gray)
    libtcod.console_rect(window,0,0,inventoryWidth,height,False,libtcod.BKGND_SCREEN)
    
    libtcod.console_set_default_foreground(window,libtcod.amber)
    libtcod.console_print_rect_ex(window,0,0,inventoryWidth,height,libtcod.BKGND_NONE,libtcod.LEFT,header)
    libtcod.console_print_rect_ex(window,0,18,28,height,libtcod.BKGND_NONE,libtcod.LEFT,"Item Name: ")
    libtcod.console_print_rect_ex(window,0,19,28,height,libtcod.BKGND_NONE,libtcod.LEFT,"Info: ")
    
    y = headerHeight
    x = 0
    for option in options:
        libtcod.console_put_char(window,x,y,option.char,libtcod.BKGND_SCREEN)
        x = x + 2
        if x == 20:
            x = 0
            y = y + 2
        
    libtcod.console_blit(window,0,0,inventoryWidth,height,0,55,1,1.0,1.0)
    
    while True:
        libtcod.console_flush()
        mousex = mouse.cx-55
        mousey = mouse.cy-6
        
        goodY = False
        goodX = False

        #hover
        if (len(options) <= 10 and mousey <= 0) or (len(options) > 10 and len(options) <= 20 and mousey <= 3) or (len(options) > 20 and len(options) <= 30 and mousey <= 5) or (len(options) > 30 and len(options) <= 40 and mousey <= 7):
            goodY = True
                
        if len(options) == 1 and mousex == 0:
            goodX = True
                
        elif len(options) == 2 and mousex <= 2:
            goodX = True
                
        elif len(options) == 3 and mousex <= 4:
            goodX = True
                
        elif len(options) == 4 and mousex <= 6:
            goodX = True
                
        elif len(options) == 5 and mousex <= 8:
            goodX = True
                
        elif len(options) == 6 and mousex <= 10:
            goodX = True
                
        elif len(options) == 7 and mousex <= 12:
            goodX = True
                
        elif len(options) == 8 and mousex <= 14:
            goodX = True
                
        elif len(options) == 9 and mousex <= 16 :
            goodX = True
                
        elif len(options) == 10 and mousex <= 18:
            goodX = True
                
        elif (len(options) == 11 and (mousex == 0 or mousey == 0)) or (len(options) == 21 and (mousex == 0 or mousey <= 1)) or (len(options) == 31 and (mousex == 0 or mousey <= 2)):
            goodX = True
                
        elif (len(options) == 12 and (mousex <= 2 or mousey == 0)) or (len(options) == 22 and (mousex <= 2 or mousey <= 1)) or (len(options) == 32 and (mousex <= 2 or mousey <= 2)):
            goodX = True
                
        elif (len(options) == 13 and (mousex <= 4 or mousey == 0)) or (len(options) == 23 and (mousex <= 4 or mousey <= 1)) or (len(options) == 33 and (mousex <= 4 or mousey <= 2)):
            goodX = True
                
        elif (len(options) == 14 and (mousex <= 6 or mousey == 0)) or (len(options) == 24 and (mousex <= 6 or mousey <= 1)) or (len(options) == 34 and (mousex <= 6 or mousey <= 2)):
            goodX = True
                
        elif (len(options) == 15 and (mousex <= 8 or mousey == 0)) or (len(options) == 25 and (mousex <= 8 or mousey <= 1)) or (len(options) == 35 and (mousex <= 8 or mousey <= 2)):
            goodX = True
                
        elif (len(options) == 16 and (mousex <= 10 or mousey == 0)) or (len(options) == 26 and (mousex <= 10 or mousey <= 1)) or (len(options) == 36 and (mousex <= 10 or mousey <= 2)):
            goodX = True
                
        elif (len(options) == 17 and (mousex <= 12 or mousey == 0)) or (len(options) == 27 and (mousex <= 12 or mousey <= 1)) or (len(options) == 37 and (mousex <= 12 or mousey <= 2)):
            goodX = True
                
        elif (len(options) == 18 and (mousex <= 14 or mousey == 0)) or (len(options) == 28 and (mousex <= 14 or mousey <= 1)) or (len(options) == 38 and (mousex <= 14 or mousey <= 2)):
            goodX = True
                
        elif (len(options) == 19 and (mousex <= 16 or mousey == 0)) or (len(options) == 29 and (mousex <= 16 or mousey <= 1)) or (len(options) == 39 and (mousex <= 16 or mousey <= 2)):
            goodX = True
                
        elif (len(options) == 20 and (mousex <= 18 or mousey == 0)) or (len(options) == 30 and (mousex <= 18 or mousey <= 1)) or (len(options) == 40 and (mousex <= 18 or mousey <= 2)):
            goodX = True
                
        if mousex < 19 and mousex >= 0 and mousey%2 == 0 and mousex%2 == 0 and goodY and mousey >= 0 and goodX:
            if len(inventory) != 0:
                index = mousex - mousex/2 + 5*mousey
                name = inventory[index].name 
                description = inventory[index].description
        else:
            name = '                '
            description = '                                                    '
            
        libtcod.console_print_ex(window,11,18,libtcod.BKGND_NONE,libtcod.LEFT,name.capitalize())
        libtcod.console_print_rect_ex(window,6,19,24,height,libtcod.BKGND_NONE,libtcod.LEFT,description)
        libtcod.console_blit(window,0,0,28,height,0,55,1,1.0,1.0)
        
        libtcod.console_flush()
        libtcod.sys_check_for_event(libtcod.EVENT_KEY_PRESS|libtcod.EVENT_MOUSE,key,mouse)
        
        goodY = False
        goodX = False
        
        #use
        if (mouse.lbutton_pressed):
            mousex = mouse.cx-55
            mousey = mouse.cy-6
            
            if (len(options) <= 10 and mousey <= 0) or (len(options) > 10 and len(options) <= 20 and mousey <= 3) or (len(options) > 20 and len(options) <= 30 and mousey <= 5) or (len(options) > 30 and len(options) <= 40 and mousey <= 7):
                goodY = True
                
            if len(options) == 1 and mousex == 0:
                goodX = True
                
            elif len(options) == 2 and mousex <= 2:
                goodX = True
                
            elif len(options) == 3 and mousex <= 4:
                goodX = True
                
            elif len(options) == 4 and mousex <= 6:
                goodX = True
                
            elif len(options) == 5 and mousex <= 8:
                goodX = True
                
            elif len(options) == 6 and mousex <= 10:
                goodX = True
                
            elif len(options) == 7 and mousex <= 12:
                goodX = True
                
            elif len(options) == 8 and mousex <= 14:
                goodX = True
                
            elif len(options) == 9 and mousex <= 16 :
                goodX = True
                
            elif len(options) == 10 and mousex <= 18:
                goodX = True
                
            elif (len(options) == 11 and (mousex == 0 or mousey == 0)) or (len(options) == 21 and (mousex == 0 or mousey <= 1)) or (len(options) == 31 and (mousex == 0 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 12 and (mousex <= 2 or mousey == 0)) or (len(options) == 22 and (mousex <= 2 or mousey <= 1)) or (len(options) == 32 and (mousex <= 2 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 13 and (mousex <= 4 or mousey == 0)) or (len(options) == 23 and (mousex <= 4 or mousey <= 1)) or (len(options) == 33 and (mousex <= 4 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 14 and (mousex <= 6 or mousey == 0)) or (len(options) == 24 and (mousex <= 6 or mousey <= 1)) or (len(options) == 34 and (mousex <= 6 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 15 and (mousex <= 8 or mousey == 0)) or (len(options) == 25 and (mousex <= 8 or mousey <= 1)) or (len(options) == 35 and (mousex <= 8 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 16 and (mousex <= 10 or mousey == 0)) or (len(options) == 26 and (mousex <= 10 or mousey <= 1)) or (len(options) == 36 and (mousex <= 10 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 17 and (mousex <= 12 or mousey == 0)) or (len(options) == 27 and (mousex <= 12 or mousey <= 1)) or (len(options) == 37 and (mousex <= 12 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 18 and (mousex <= 14 or mousey == 0)) or (len(options) == 28 and (mousex <= 14 or mousey <= 1)) or (len(options) == 38 and (mousex <= 14 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 19 and (mousex <= 16 or mousey == 0)) or (len(options) == 29 and (mousex <= 16 or mousey <= 1)) or (len(options) == 39 and (mousex <= 16 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 20 and (mousex <= 18 or mousey == 0)) or (len(options) == 30 and (mousex <= 18 or mousey <= 1)) or (len(options) == 40 and (mousex <= 18 or mousey <= 2)):
                goodX = True
                
            if mousex < 19 and mousex >= 0 and mousey%2 == 0 and mousex%2 == 0 and goodY and mousey >= 0 and goodX:
                if len(inventory) != 0:
                    index = mousex - mousex/2 + 5*mousey
                    return inventory[index]
         
        #drop       
        if (mouse.rbutton_pressed):
            mousex = mouse.cx-55
            mousey = mouse.cy-6
            
            if (len(options) <= 10 and mousey <= 0) or (len(options) > 10 and len(options) <= 20 and mousey <= 3) or (len(options) > 20 and len(options) <= 30 and mousey <= 5) or (len(options) > 30 and len(options) <= 40 and mousey <= 7):
                goodY = True
                
            if len(options) == 1 and mousex == 0:
                goodX = True
                
            elif len(options) == 2 and mousex <= 2:
                goodX = True
                
            elif len(options) == 3 and mousex <= 4:
                goodX = True
                
            elif len(options) == 4 and mousex <= 6:
                goodX = True
                
            elif len(options) == 5 and mousex <= 8:
                goodX = True
                
            elif len(options) == 6 and mousex <= 10:
                goodX = True
                
            elif len(options) == 7 and mousex <= 12:
                goodX = True
                
            elif len(options) == 8 and mousex <= 14:
                goodX = True
                
            elif len(options) == 9 and mousex <= 16 :
                goodX = True
                
            elif len(options) == 10 and mousex <= 18:
                goodX = True
                
            elif (len(options) == 11 and (mousex == 0 or mousey == 0)) or (len(options) == 21 and (mousex == 0 or mousey <= 1)) or (len(options) == 31 and (mousex == 0 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 12 and (mousex <= 2 or mousey == 0)) or (len(options) == 22 and (mousex <= 2 or mousey <= 1)) or (len(options) == 32 and (mousex <= 2 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 13 and (mousex <= 4 or mousey == 0)) or (len(options) == 23 and (mousex <= 4 or mousey <= 1)) or (len(options) == 33 and (mousex <= 4 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 14 and (mousex <= 6 or mousey == 0)) or (len(options) == 24 and (mousex <= 6 or mousey <= 1)) or (len(options) == 34 and (mousex <= 6 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 15 and (mousex <= 8 or mousey == 0)) or (len(options) == 25 and (mousex <= 8 or mousey <= 1)) or (len(options) == 35 and (mousex <= 8 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 16 and (mousex <= 10 or mousey == 0)) or (len(options) == 26 and (mousex <= 10 or mousey <= 1)) or (len(options) == 36 and (mousex <= 10 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 17 and (mousex <= 12 or mousey == 0)) or (len(options) == 27 and (mousex <= 12 or mousey <= 1)) or (len(options) == 37 and (mousex <= 12 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 18 and (mousex <= 14 or mousey == 0)) or (len(options) == 28 and (mousex <= 14 or mousey <= 1)) or (len(options) == 38 and (mousex <= 14 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 19 and (mousex <= 16 or mousey == 0)) or (len(options) == 29 and (mousex <= 16 or mousey <= 1)) or (len(options) == 39 and (mousex <= 16 or mousey <= 2)):
                goodX = True
                
            elif (len(options) == 20 and (mousex <= 18 or mousey == 0)) or (len(options) == 30 and (mousex <= 18 or mousey <= 1)) or (len(options) == 40 and (mousex <= 18 or mousey <= 2)):
                goodX = True
                
            if mousex < 19 and mousex >= 0 and mousey%2 == 0 and mousex%2 == 0 and goodY and mousey >= 0 and goodX:
                if len(inventory) != 0:
                    drop = True
                    index = mousex - mousex/2 + 5*mousey
                    return inventory[index]
            
        if key.vk == libtcod.KEY_ENTER:
            return None
    
    return None

def equipment_menu(header):
    global key,mouse
    goodY = False
    global equipped_list
    options = [item for item in equipped_list]
    
    if len(options) > 6: raise ValueError('Cannot have a menu with more than 6 options.')
    
    headerHeight = libtcod.console_get_height_rect(con,0,0,equipmentWidth,screenHeight,header)
    if header == '':
        headerHeight = 0
    height = 23 + headerHeight
    
    window = libtcod.console_new(equipmentWidth,height)
    libtcod.console_set_default_background(window,libtcod.gray)
    libtcod.console_rect(window,0,0,equipmentWidth,height,False,libtcod.BKGND_SCREEN)
    
    libtcod.console_set_default_foreground(window,libtcod.amber)
    libtcod.console_print_rect_ex(window,0,0,equipmentWidth,height,libtcod.BKGND_NONE,libtcod.LEFT,header) 
    line = "HP = " + str(player.fighter.max_hp)
    libtcod.console_print_rect_ex(window,1,24,equipmentWidth,height,libtcod.BKGND_NONE,libtcod.LEFT,line)    
    line = "Defense Rating = " + str(player.fighter.defense)
    libtcod.console_print_rect_ex(window,1,25,equipmentWidth,height,libtcod.BKGND_NONE,libtcod.LEFT,line)    
    line = "Attack Power = " + str(player.fighter.power)
    libtcod.console_print_rect_ex(window,1,26,equipmentWidth,height,libtcod.BKGND_NONE,libtcod.LEFT,line)    

    
    for option in options:
        if option.equipment.slot == 'head':
            libtcod.console_put_char(window,9,6,option.char,libtcod.BKGND_SCREEN)
            
        elif option.equipment.slot == 'chest':
            libtcod.console_put_char(window,9,11,option.char,libtcod.BKGND_SCREEN)
            
        elif option.equipment.slot == 'legs':
            libtcod.console_put_char(window,9,16,option.char,libtcod.BKGND_SCREEN)
            
        elif option.equipment.slot == 'feet':
            libtcod.console_put_char(window,9,21,option.char,libtcod.BKGND_SCREEN)
            
        elif option.equipment.slot == 'hands':
            libtcod.console_put_char(window,3,13,option.char,libtcod.BKGND_SCREEN)
            
        elif option.equipment.slot == 'weapon':
            libtcod.console_put_char(window,15,13,option.char,libtcod.BKGND_SCREEN)

    libtcod.console_set_default_background(window,libtcod.blue)
        
    #helm coords = (63,6) - (65,8)
    libtcod.console_rect(window,equipmentWidth/2-2,headerHeight,3,3,False,libtcod.BKGND_SCREEN)
    
    #chest coords = (63,11) - (65,13)
    libtcod.console_rect(window,equipmentWidth/2-2,headerHeight+5,3,3,False,libtcod.BKGND_SCREEN)
    
    #legs coords = (63,16) - (65,19)
    libtcod.console_rect(window,equipmentWidth/2-2,headerHeight+10,3,3,False,libtcod.BKGND_SCREEN)
    
    #feet coords = (63,21) - (65,24)
    libtcod.console_rect(window,equipmentWidth/2-2,headerHeight+15,3,3,False,libtcod.BKGND_SCREEN)
    
    #hands coords = (57,13) - (59,16)
    libtcod.console_rect(window,equipmentWidth/3-4,headerHeight+7,3,3,False,libtcod.BKGND_SCREEN)
    
    #weapon coords = (69,13) - (71,16)
    libtcod.console_rect(window,equipmentWidth/3*2+2,headerHeight+7,3,3,False,libtcod.BKGND_SCREEN)
            
    libtcod.console_blit(window,0,0,equipmentWidth,height,0,55,1,1.0,1.0)
    
    while True:
        libtcod.console_flush()
        libtcod.sys_check_for_event(libtcod.EVENT_KEY_PRESS|libtcod.EVENT_MOUSE,key,mouse)
        
        if (mouse.lbutton_pressed):
            mousex = mouse.cx
            mousey = mouse.cy
            
            #selected head
            if mousex >= 63 and mousex <= 65 and mousey >= 6 and mousey <= 8:
                for option in options:
                    if option.equipemnt.slot == 'head':
                        if get_equipped_in_slot('head') != None:
                            return option
                            
            #selected chest                  
            elif mousex >= 63 and mousex <= 65 and mousey >= 11 and mousey <= 13:
                for option in options:
                    if option.equipment.slot == 'chest':
                        if get_equipped_in_slot('chest') != None:
                            return option
    
            #selected legs
            elif mousex >= 63 and mousex <= 65 and mousey >= 16 and mousey <= 19:
                for option in options:
                    if option.equipment.slot == 'legs':
                        if get_equipped_in_slot('legs') != None:
                            return option
            
            #selected feet                    
            elif mousex >= 63 and mousex <= 65 and mousey >= 21 and mousey <= 24:
                for option in options:
                    if option.equipment.slot == 'feet':
                        if get_equipped_in_slot('feet') != None:
                            return option
                            
            #selected hands                    
            elif mousex >= 57 and mousex <= 59 and mousey >= 13 and mousey <= 16:
                for option in options:
                    if option.equipment.slot == 'hands':
                        if get_equipped_in_slot('hands') != None:
                            return option
            
            #selected weapon
            elif mousex >= 69 and mousex <= 71 and mousey >= 13 and mousey <= 16:
                for option in options:
                    if option.equipment.slot == 'weapon':
                        if get_equipped_in_slot('weapon') != None:
                            return option
            
        if key.vk == libtcod.KEY_ENTER:
            return None
    
    return None
    
def abilities_menu(header):
    global key,mouse
    global playerSkillPoints
    global allAbilities
    options = [ability for ability in allAbilities]
    
    if len(options) > 45: raise ValueError('Cannot have a menu with more than 40 options.')
    
    headerHeight = libtcod.console_get_height_rect(con,0,0,18,screenHeight,header)
    if header == '':
        headerHeight = 0
    height = 20 + headerHeight
    
    window = libtcod.console_new(28,height)
    libtcod.console_set_default_background(window,libtcod.gray)
    libtcod.console_rect(window,0,0,28,height,False,libtcod.BKGND_SCREEN)
    
    libtcod.console_set_default_foreground(window,libtcod.amber)
    libtcod.console_print_rect_ex(window,0,0,28,height,libtcod.BKGND_NONE,libtcod.LEFT,header)
    libtcod.console_print_rect_ex(window,1,5,28,height,libtcod.BKGND_NONE,libtcod.LEFT,"Pyromancer")
    libtcod.console_print_rect_ex(window,1,7,28,height,libtcod.BKGND_NONE,libtcod.LEFT,"Cryomancer")
    libtcod.console_print_rect_ex(window,1,9,28,height,libtcod.BKGND_NONE,libtcod.LEFT,"Necromancer")
    libtcod.console_print_rect_ex(window,1,11,28,height,libtcod.BKGND_NONE,libtcod.LEFT,"Psychic")
    libtcod.console_print_rect_ex(window,1,13,28,height,libtcod.BKGND_NONE,libtcod.LEFT,"Healer")
    libtcod.console_print_rect_ex(window,0,15,28,height,libtcod.BKGND_NONE,libtcod.LEFT,"Unspent Skill Points = " + str(playerSkillPoints))
    libtcod.console_print_rect_ex(window,0,18,28,height,libtcod.BKGND_NONE,libtcod.LEFT,"Skill Name: ")
    libtcod.console_print_rect_ex(window,0,19,28,height,libtcod.BKGND_NONE,libtcod.LEFT,"Info: ")

    y = headerHeight
    x = 13
    for option in options:
        libtcod.console_put_char(window,x,y,option.icon,libtcod.BKGND_SCREEN)
        x = x + 2
        if x >= 22:
            x = 13
            y = y + 2
           
    libtcod.console_blit(window,0,0,28,height,0,55,1,1.0,1.0)
    
    while True:
        libtcod.console_flush()
        mousex = mouse.cx-55
        mousey = mouse.cy-6
        name = None
    
        if mousex == 13 and mousey == 0:
            name = allAbilities[0].name 
            description = allAbilities[0].description
        elif mousex == 15 and mousey == 0:
            name = allAbilities[1].name 
            description = allAbilities[1].description
        else:
            name = '                '
            description = '                                                    '
            
        libtcod.console_print_ex(window,12,18,libtcod.BKGND_NONE,libtcod.LEFT,name.capitalize())
        libtcod.console_print_rect_ex(window,6,19,24,height,libtcod.BKGND_NONE,libtcod.LEFT,description)
        libtcod.console_blit(window,0,0,28,height,0,55,1,1.0,1.0)
        
        libtcod.console_flush()

        libtcod.sys_check_for_event(libtcod.EVENT_KEY_PRESS|libtcod.EVENT_MOUSE,key,mouse)
        
        if (mouse.lbutton_pressed):
            mousex = mouse.cx-55
            mousey = mouse.cy-6
            
            #selected spell in pyromancer
            if mousex == 13 and mousey == 0:
                return allAbilities[0] 
            
            elif mousex == 15 and mousey == 0:
                return allAbilities[1]  

            elif mousex == 17 and mousey == 0:
                return allAbilities[2]  

            elif mousex == 19 and mousey == 0:
                return allAbilities[3]  
      
            elif mousex == 21 and mousey == 0:
                return allAbilities[4]  

            #selected spell in cryomancer   
            elif mousex == 13 and mousey == 2:
                return allAbilities[5]  
        
            elif mousex == 15 and mousey == 2:
                return allAbilities[6] 

            elif mousex == 17 and mousey == 2:
                return allAbilities[7]  

            elif mousex == 19 and mousey == 2:
                return allAbilities[8]  
         
            elif mousex == 21 and mousey == 2:
                return allAbilities[9]  

            #selected spell in necromancer
            elif mousex == 13 and mousey == 4:
                return allAbilities[10]  
 
            elif mousex == 15 and mousey == 4:
                return allAbilities[11]  

            elif mousex == 17 and mousey == 4:
                return allAbilities[12]  

            elif mousex == 19 and mousey == 4:
                return allAbilities[13]  

            elif mousex == 21 and mousey == 4:
                return allAbilities[14] 

            #selected spell in psychic
            elif mousex == 13 and mousey == 6:
                return allAbilities[15]  
      
            elif mousex == 15 and mousey == 6:
                return allAbilities[16]  

            elif mousex == 17 and mousey == 6:
                return allAbilities[17]  

            elif mousex == 19 and mousey == 6:
                return allAbilities[18]  
          
            elif mousex == 21 and mousey == 6:
                return allAbilities[19]  

            #selected spell in healer
            elif mousex == 13 and mousey == 8:
                return allAbilities[20] 
          
            elif mousex == 15 and mousey == 8:
                return allAbilities[21]  

            elif mousex == 17 and mousey == 8:
                return allAbilities[22]  

            elif mousex == 19 and mousey == 8:
                return allAbilities[23]  
           
            elif mousex == 21 and mousey == 8:
                return allAbilities[24] 
            
        if (mouse.rbutton_pressed):
            mousex = mouse.cx-55
            mousey = mouse.cy-6
            
            #selected spell in pyromancer
            if mousex == 13 and mousey == 0:
                if allAbilities[0].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[0].learned = True
                        message('You learned ' + allAbilities[0].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[0].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[0].name + '.', libtcod.orange)
                    return None  
            
            elif mousex == 15 and mousey == 0:
                if allAbilities[1].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[1].learned = True
                        message('You learned ' + allAbilities[1].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[1].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[1].name + '.', libtcod.orange)
                    return None  
                
            elif mousex == 17 and mousey == 0:
                if allAbilities[2].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[2].learned = True
                        message('You learned ' + allAbilities[2].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[2].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[2].name + '.', libtcod.orange)
                    return None  
                
            elif mousex == 19 and mousey == 0:
                if allAbilities[3].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[3].learned = True
                        message('You learned ' + allAbilities[3].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[3].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[3].name + '.', libtcod.orange)
                    return None  
                     
            elif mousex == 21 and mousey == 0:
                if allAbilities[4].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[4].learned = True
                        message('You learned ' + allAbilities[4].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[4].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[4].name + '.', libtcod.orange)
                    return None  
                
                
            #selected spell in cryomancer   
            elif mousex == 13 and mousey == 2:
                if allAbilities[5].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[5].learned = True
                        message('You learned ' + allAbilities[5].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[5].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[5].name + '.', libtcod.orange)
                    return None  
                        
            elif mousex == 15 and mousey == 2:
                if allAbilities[6].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[6].learned = True
                        message('You learned ' + allAbilities[6].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[6].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[6].name + '.', libtcod.orange)
                    return None  
                
            elif mousex == 17 and mousey == 2:
                if allAbilities[7].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[7].learned = True
                        message('You learned ' + allAbilities[7].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[7].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[7].name + '.', libtcod.orange)
                    return None  
                
            elif mousex == 19 and mousey == 2:
                if allAbilities[8].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[8].learned = True
                        message('You learned ' + allAbilities[8].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[8].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[8].name + '.', libtcod.orange)
                    return None  
                         
            elif mousex == 21 and mousey == 2:
                if allAbilities[9].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[9].learned = True
                        message('You learned ' + allAbilities[9].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[9].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[9].name + '.', libtcod.orange)
                    return None  
                
                
            #selected spell in necromancer
            elif mousex == 13 and mousey == 4:
                if allAbilities[10].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[10].learned = True
                        message('You learned ' + allAbilities[10].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[10].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[10].name + '.', libtcod.orange)
                    return None  
                 
            elif mousex == 15 and mousey == 4:
                if allAbilities[11].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[11].learned = True
                        message('You learned ' + allAbilities[11].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[11].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[11].name + '.', libtcod.orange)
                    return None  
                
            elif mousex == 17 and mousey == 4:
                if allAbilities[12].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[12].learned = True
                        message('You learned ' + allAbilities[12].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[12].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[12].name + '.', libtcod.orange)
                    return None  
                
            elif mousex == 19 and mousey == 4:
                if allAbilities[13].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[13].learned = True
                        message('You learned ' + allAbilities[13].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[13].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[13].name + '.', libtcod.orange)
                    return None  
                
            elif mousex == 21 and mousey == 4:
                if allAbilities[14].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[14].learned = True
                        message('You learned ' + allAbilities[14].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[14].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[14].name + '.', libtcod.orange)
                    return None  
                
                
            #selected spell in psychic
            elif mousex == 13 and mousey == 6:
                if allAbilities[15].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[15].learned = True
                        message('You learned ' + allAbilities[15].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[15].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[15].name + '.', libtcod.orange)
                    return None  
                      
            elif mousex == 15 and mousey == 6:
                if allAbilities[16].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[16].learned = True
                        message('You learned ' + allAbilities[16].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[16].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[16].name + '.', libtcod.orange)
                    return None  
                
            elif mousex == 17 and mousey == 6:
                if allAbilities[17].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[17].learned = True
                        message('You learned ' + allAbilities[17].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[17].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[17].name + '.', libtcod.orange)
                    return None  
                
            elif mousex == 19 and mousey == 6:
                if allAbilities[18].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[18].learned = True
                        message('You learned ' + allAbilities[18].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[18].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[18].name + '.', libtcod.orange)
                    return None 
                          
            elif mousex == 21 and mousey == 6:
                if allAbilities[19].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[19].learned = True
                        message('You learned ' + allAbilities[19].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[19].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[19].name + '.', libtcod.orange)
                    return None 
                
                
            #selected spell in healer
            elif mousex == 13 and mousey == 8:
                if allAbilities[20].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[20].learned = True
                        message('You learned ' + allAbilities[20].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[20].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[20].name + '.', libtcod.orange)
                    return None  
  
                       
            elif mousex == 15 and mousey == 8:
                if allAbilities[21].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[21].learned = True
                        message('You learned ' + allAbilities[21].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[21].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[21].name + '.', libtcod.orange)
                    return None 
                
            elif mousex == 17 and mousey == 8:
                if allAbilities[22].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[22].learned = True
                        message('You learned ' + allAbilities[22].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[22].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[22].name + '.', libtcod.orange)
                    return None 
                
            elif mousex == 19 and mousey == 8:
                if allAbilities[23].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[23].learned = True
                        message('You learned ' + allAbilities[23].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[23].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[23].name + '.', libtcod.orange)
                    return None 
                          
            elif mousex == 21 and mousey == 8:
                if allAbilities[24].learned == False:
                    if playerSkillPoints > 0:
                        allAbilities[24].learned = True
                        message('You learned ' + allAbilities[24].name + '.', libtcod.green) 
                        playerSkillPoints = playerSkillPoints - 1
                        return None
                    else:
                        message('You do not have enough skill points to learn ' + allAbilities[24].name + '.', libtcod.orange)
                        return None  
                else:
                    message('You already know ' + allAbilities[24].name + '.', libtcod.orange)
                    return None 
                  
        if key.vk == libtcod.KEY_ENTER:
            return None
    
    return None    
    
def handleKeys():
    global playerx, playery, key, mouse, fovRecompute
    global prevTime
    global cantAttack
    global allAbilities
        
    #Add fullscreen support here?
    
    #key handling
    if mouse.lbutton_pressed:
        if game_state == 'playing':
            player_select_or_attack(mouse.cx,mouse.cy,prevTime)
            if cantAttack == False:
                prevTime = time.time()
                cantAttack = True
    
    if key.vk == libtcod.KEY_ESCAPE: #exit game
        return 'exit'

    else: #other keys
        key_char = chr(key.c)
        if game_state == 'playing':
            if key.vk == libtcod.KEY_UP:
                player.move(0,-1)
                fovRecompute = True
                for object in objects:
                    if object.x == player.x and object.y == player.y and object.item:
                        object.item.pick_up()
                        break
            elif key.vk == libtcod.KEY_DOWN:
                player.move(0,1)
                fovRecompute = True
                for object in objects:
                    if object.x == player.x and object.y == player.y and object.item:
                        object.item.pick_up()
                        break
            elif key.vk == libtcod.KEY_LEFT:
                player.move(-1,0)
                fovRecompute = True
                for object in objects:
                    if object.x == player.x and object.y == player.y and object.item:
                        object.item.pick_up()
                        break
            elif key.vk == libtcod.KEY_RIGHT:
                player.move(1,0)
                fovRecompute = True
                for object in objects:
                    if object.x == player.x and object.y == player.y and object.item:
                        object.item.pick_up()
                        break
            elif key_char == 'w':
                player.move(0,-1)
                fovRecompute = True
                for object in objects:
                    if object.x == player.x and object.y == player.y and object.item:
                        object.item.pick_up()
                        break
            elif key_char == 's':
                player.move(0,1)
                fovRecompute = True
                for object in objects:
                    if object.x == player.x and object.y == player.y and object.item:
                        object.item.pick_up()
                        break
            elif key_char == 'a':
                player.move(-1,0)
                fovRecompute = True
                for object in objects:
                    if object.x == player.x and object.y == player.y and object.item:
                        object.item.pick_up()
                        break
            elif key_char == 'd':
                player.move(1,0)
                fovRecompute = True
                for object in objects:
                    if object.x == player.x and object.y == player.y and object.item:
                        object.item.pick_up()
                        break
            elif key.vk == libtcod.KEY_1:
                if len(hotbarAbilities) <= 0:
                    message("No spell loaded.", libtcod.orange)
                else:
                    hotbarAbilities[0].cast()
                return
            elif key.vk == libtcod.KEY_2:
                if len(hotbarAbilities) <= 1:
                    message("No spell loaded.", libtcod.orange)
                else:
                    hotbarAbilities[1].cast()
                return
            elif key.vk == libtcod.KEY_3:
                if len(hotbarAbilities) <= 2:
                    message("No spell loaded.", libtcod.orange)
                else:
                    hotbarAbilities[2].cast()
                return
            elif key.vk == libtcod.KEY_4:
                if len(hotbarAbilities) <= 3:
                    message("No spell loaded.", libtcod.orange)
                else:
                    hotbarAbilities[3].cast()
                return
            elif key.vk == libtcod.KEY_5:
                if len(hotbarAbilities) <= 4:
                    message("No spell loaded.", libtcod.orange)
                else:
                    hotbarAbilities[4].cast()
                return
            elif key.vk == libtcod.KEY_6:
                if len(hotbarAbilities) <= 5:
                    message("No spell loaded.", libtcod.orange)
                else:
                    hotbarAbilities[5].cast()
                return
            elif key.vk == libtcod.KEY_7:
                if len(hotbarAbilities) <= 6:
                    message("No spell loaded.", libtcod.orange)
                else:
                    hotbarAbilities[6].cast()
                return
            elif key.vk == libtcod.KEY_8:
                if len(hotbarAbilities) <= 7:
                    message("No spell loaded.", libtcod.orange)
                else:
                    hotbarAbilities[7].cast()
                return
            elif key.vk == libtcod.KEY_9:
                if len(hotbarAbilities) <= 8:
                    message("No spell loaded.", libtcod.orange)
                else:
                    hotbarAbilities[8].cast()
                return
            elif key.vk == libtcod.KEY_SPACE:
                if stairs.x == player.x and stairs.y == player.y:
                    next_level()
       
def target_monster():
    while True:
        libtcod.console_flush()
        libtcod.sys_check_for_event(libtcod.EVENT_KEY_PRESS|libtcod.EVENT_MOUSE,key,mouse)
        renderAll()
            
        (x,y) = mouse.cx, mouse.cy
        (x,y) = x + camera_x, y + camera_y
            
        if (mouse.lbutton_pressed and libtcod.map_is_in_fov(fovMap,x,y)):
            target = None
            for object in objects:
                if object.x == x and object.y == y:
                    if object.fighter is not None:
                        target = object
                        break
            return target


def player_death(player):
    global game_state
    message("You died.", libtcod.red)
    game_state = 'dead'
    
def monster_death(monster):
    global playerExperiencePoints
    
    message(monster.name.capitalize() + ' is dead!', libtcod.green)
    playerExperiencePoints = playerExperiencePoints + monster.fighter.experienceWorth
    objects.remove(monster)
    
def cast_heal():
    if player.fighter.hp == player.fighter.max_hp:
        message('You are already at full health!', libtcod.orange)
        return 'cancelled'
    message('Your wounds begin to heal.', libtcod.green)
    player.fighter.heal(healAmount)

def save_game():
    file = shelve.open('savegame','n')
    file['dungeon'] = dungeon
    file['objects'] = objects
    file['player_index'] = objects.index(player)
    file['inventory'] = inventory
    file['equipped_list'] = equipped_list
    file['playerLevel'] = playerLevel
    file['playerSkillPoints'] = playerSkillPoints
    file['playerExperiencePoints'] = playerExperiencePoints
    file['experienceMax'] = experienceMax 
    file['allMessages'] = allMessages
    file['game_state'] = game_state
    file['hotbarAbilities'] = hotbarAbilities
    file['allAbilities'] = allAbilities
    file['stairs_index'] = objects.index(stairs)
    file['dungeonLevel'] = dungeonLevel
    file.close()
    
def load_game():
    global dungeon, objects, player, inventory, equipped_list,playerLevel, playerSkillPoints, playerExperiencePoints, experienceMax, allMessages, game_state, hotbarAbilities, allAbilities, stairs, dungeonLevel
    file = shelve.open('savegame', 'r')
    dungeon = file['dungeon']
    objects = file['objects']
    player = objects[file['player_index']]
    inventory = file['inventory']
    equipped_list = file['equipped_list']
    playerLevel = file['playerLevel']
    playerSkillPoints = file['playerSkillPoints']
    playerExperiencePoints = file['playerExperiencePoints']
    experienceMax = file['experienceMax']
    allMessages = file['allMessages']
    game_state = file['game_state']
    hotbarAbilities = file['hotbarAbilities']
    allAbilities = file['allAbilities']
    stairs = objects[file['stairs_index']]
    dungeonLevel = file['dungeonLevel']
    file.close()
    initializeFOV()
    
def new_game():
    global player, inventory, equipped_list, hotbarAbilities, allMessages, game_state, playerLevel, playerExperiencePoints, playerSkillPoints, experienceMax, allAbilities, dungeonLevel
    
    fighter_component = Fighter(hp=100,defense=1,power=4,mana=100,death_function=player_death)
    player = Object(65, 60, player_tile, 'the hero', libtcod.white, 0, 0, 0, False, blocks=True, fighter=fighter_component)
    
    dungeonLevel = 1
    makeMap(dungeon1levelL1)
    initializeFOV()
    
    game_state = 'playing'

    #initialize messages
    allMessages = []
    message('Welcome! This is a sample printed message.', libtcod.green)

    #initialize equipment
    inventory = []
    equipped_list = []

    #initialize abilities
    allAbilities = []
    hotbarAbilities = []

    fireball = Spell('fireball', scroll_tile, 'single-target', 2, 20, 10, False, "A firey spell that deals 5 damage.")
    fireball2 = Spell('fireball 2', scroll_tile, 'single-target', 2, 20, 5, False)
    fireball3 = Spell('fireball', scroll_tile, 'single-target', 2, 20, 5, False)
    fireball4 = Spell('fireball' , scroll_tile, 'single-target', 2, 20, 5, False)
    fireball5 = Spell('fireball', scroll_tile, 'single-target', 2, 20, 5, False)
    allAbilities.append(fireball)
    allAbilities.append(fireball2)
    allAbilities.append(fireball3)
    allAbilities.append(fireball4)
    allAbilities.append(fireball5)

    iceball = Spell('iceball', scroll_tile, 'single-target', 2, 20, 5, False)
    iceball2 = Spell('iceball', scroll_tile, 'single-target', 2, 20, 5, False)
    iceball3 = Spell('iceball', scroll_tile, 'single-target', 2, 20, 5, False)
    iceball4 = Spell('iceball', scroll_tile, 'single-target', 2, 20, 5, False)
    iceball5 = Spell('iceball', scroll_tile, 'single-target', 2, 20, 5, False)
    allAbilities.append(iceball)
    allAbilities.append(iceball2)
    allAbilities.append(iceball3)
    allAbilities.append(iceball4)
    allAbilities.append(iceball5)

    deathball = Spell('deathball', scroll_tile, 'single-target', 2, 20, 5, False)
    deathball2 = Spell('deathball', scroll_tile, 'single-target', 2, 20, 5, False)
    deathball3 = Spell('deathball', scroll_tile, 'single-target', 2, 20, 5, False)
    deathball4 = Spell('deathball', scroll_tile, 'single-target', 2, 20, 5, False)
    deathball5 = Spell('deathball', scroll_tile, 'single-target', 2, 20, 5, False)
    allAbilities.append(deathball)
    allAbilities.append(deathball2)
    allAbilities.append(deathball3)
    allAbilities.append(deathball4)
    allAbilities.append(deathball5)

    psychicball = Spell('psychicball', scroll_tile, 'single-target', 2, 20, 5, False)
    psychicball2 = Spell('psychicball', scroll_tile, 'single-target', 2, 20, 5, False)
    psychicball3 = Spell('psychicball', scroll_tile, 'single-target', 2, 20, 5, False)
    psychicball4 = Spell('psychicball', scroll_tile, 'single-target', 2, 20, 5, False)
    psychicball5 = Spell('psychicball', scroll_tile, 'single-target', 2, 20, 5, False)
    allAbilities.append(psychicball)
    allAbilities.append(psychicball2)
    allAbilities.append(psychicball3)
    allAbilities.append(psychicball4)
    allAbilities.append(psychicball5)

    lightball = Spell('lightball', scroll_tile, 'single-target', 2, 20, 5, False)
    lightball2 = Spell('lightball', scroll_tile, 'single-target', 2, 20, 5, False)
    lightball3 = Spell('lightball', scroll_tile, 'single-target', 2, 20, 5, False)
    lightball4 = Spell('lightball', scroll_tile, 'single-target', 2, 20, 5, False)
    lightball5 = Spell('lightball', scroll_tile, 'single-target', 2, 20, 5, False)
    allAbilities.append(lightball)
    allAbilities.append(lightball2)
    allAbilities.append(lightball3)
    allAbilities.append(lightball4)
    allAbilities.append(lightball5)

    #initialize progression info
    playerLevel = 1
    playerSkillPoints = 0
    playerExperiencePoints = 0
    experienceMax = 100   

def next_level():
    global dungeonLevel
    message('You descend deeper into the dungeon...', libtcod.green)
    dungeonLevel = dungeonLevel + 1
    makeRandomMap()
    initializeFOV()
    
def initializeFOV():
    global fovRecompute, fovMap
    fovRecompute = True   
    fovMap = libtcod.map_new(len(dungeon), len(dungeon[0]))
    for y in range(len(dungeon[0])):
        for x in range(len(dungeon)):
            libtcod.map_set_properties(fovMap, x, y, not Tile(dungeon[x][y]).block_sight, not Tile(dungeon[x][y]).blocked)
    libtcod.console_clear(con)

def play_game():
    global camera_x, camera_y, key, mouse, playerLevel, hotbarAbilities, prevTime, manaUse, playerExperiencePoints, experienceMax, cantAttack, allAbilities, playerSkillPoints

    #initialize mouse and keys
    mouse = libtcod.Mouse()
    key = libtcod.Key()

    #initialize camera
    (camera_x, camera_y) = (player.x, player.y)

    #initialize attack values
    prevTime = time.time()
    manaUse = int(time.time())
    cantAttack = False

    #main loop
    while not libtcod.console_is_window_closed():
        libtcod.sys_check_for_event(libtcod.EVENT_KEY_PRESS|libtcod.EVENT_MOUSE,key,mouse)
        renderAll()
        libtcod.console_flush()
    
        for object in objects:
            object.clear()
        
        if handleKeys() == 'exit': #escape key pressed
            save_game()
            break
    
        if game_state == 'playing':
            for object in objects:
                if object.ai:
                    if object.wait > 0:
                        object.wait = object.wait-1
                    else:
                        object.ai.take_turn()
                    
            if player.fighter.mana < 100 and int(time.time()) >= manaUse + 1:
                player.fighter.mana = player.fighter.mana + 1
                manaUse = int(time.time())
            
            if playerExperiencePoints >= experienceMax:
                playerLevel = playerLevel + 1
                message("You leveled up! You are now level " + str(playerLevel) + ". You earned 1 skill point.", libtcod.green)
                playerSkillPoints = playerSkillPoints + 1
                playerExperiencePoints = playerExperiencePoints - experienceMax
                experienceMax = experienceMax + 100
                
                choice = None
                while choice == None:
                    choice = levelUpMenu('Level up! Choose a stat to raise:\n',['+20 HP', '+10 Mana', '+1 Attack', '+1 Defense'],40)
                    if choice == 0:
                        player.fighter.max_hp += 20
                        player.fighter.hp += 20
                    elif choice == 1:
                        player.fighter.max_mana += 10
                        player.fighter.mana += 10
                    elif choice == 2:
                        player.fighter.power += 1
                    elif choice == 3:
                        player.fighter.defense += 1
def main_menu():
    while not libtcod.console_is_window_closed():
        libtcod.console_set_default_foreground(0,libtcod.light_yellow)
        libtcod.console_print_ex(0,screenWidth/2,screenHeight/2-6,libtcod.BKGND_NONE,libtcod.CENTER,'Roguelike')
        libtcod.console_print_ex(0,screenWidth/2,screenHeight/2-4,libtcod.BKGND_NONE,libtcod.CENTER,'By Branaugh and Adam')
        
        choice = mainMenuGraphic('',['Continue', 'Save Game', 'Load Last Game', 'New Game', 'Quit'], 24)
        if choice == 0:
            try:
                play_game()
            except:
                mainMenuGraphic('\n No data to load. Press any key to return to the main menu. \n',[], 24)
                continue
        elif choice == 1:
            try:
                save_game()
            except:
                mainMenuGraphic('\n No data to save. Press any key to return to the main menu. \n',[], 24)
                continue
            play_game()
        elif choice == 2:
            try:
                load_game()
            except:
                mainMenuGraphic('\n No saved game to load. Press any key to return to the main menu. \n',[], 24)
                continue
            play_game()
        elif choice == 3:
            new_game()
            play_game()
        elif choice == 4:
            break
    
#load console
libtcod.console_set_custom_font('Tiles.png',libtcod.FONT_TYPE_GREYSCALE | libtcod.FONT_LAYOUT_TCOD, 32, 10)
libtcod.console_init_root(screenWidth, screenHeight, 'Branaugh/Adam Roguelike', False)
libtcod.sys_set_fps(limitFPS)
con = libtcod.console_new(screenWidth,screenHeight)
panel = libtcod.console_new(screenWidth, panelHeight)
load_customfont()

main_menu()